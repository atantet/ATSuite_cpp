\hypertarget{transfer_operator_8hpp}{}\section{/\+Users/atantet/\+Ph\+D/dev/\+A\+T\+Suite/cpp/transfer\+Operator.hpp File Reference}
\label{transfer_operator_8hpp}\index{/\+Users/atantet/\+Ph\+D/dev/\+A\+T\+Suite/cpp/transfer\+Operator.\+hpp@{/\+Users/atantet/\+Ph\+D/dev/\+A\+T\+Suite/cpp/transfer\+Operator.\+hpp}}


Calculate discretized approximation of transfer operators from time series.  


{\ttfamily \#include $<$iostream$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$gsl/gsl\+\_\+vector.\+h$>$}\\*
{\ttfamily \#include $<$gsl/gsl\+\_\+vector\+\_\+uint.\+h$>$}\\*
{\ttfamily \#include $<$gsl/gsl\+\_\+matrix.\+h$>$}\\*
{\ttfamily \#include $<$gsl/gsl\+\_\+matrix\+\_\+uint.\+h$>$}\\*
{\ttfamily \#include $<$Eigen/\+Dense$>$}\\*
{\ttfamily \#include $<$Eigen/\+Sparse$>$}\\*
{\ttfamily \#include $<$omp.\+h$>$}\\*
{\ttfamily \#include $<$A\+T\+Suite/atmatrix.\+hpp$>$}\\*
{\ttfamily \#include $<$A\+T\+Suite/atmarkov.\+hpp$>$}\\*
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef Eigen\+::\+Triplet$<$ double $>$ \hyperlink{transfer_operator_8hpp_abf4a98d0009ef51cab3a1934054c6ddd}{triplet}
\begin{DoxyCompactList}\small\item\em Eigen triplet of double. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \hyperlink{transfer_operator_8hpp_abf4a98d0009ef51cab3a1934054c6ddd}{triplet} $>$ \hyperlink{transfer_operator_8hpp_a9acc52217b04e27072f5918fd1bb00c7}{triplet\+Vector}
\begin{DoxyCompactList}\small\item\em S\+TD vector of Eigen triplet of double. \end{DoxyCompactList}\item 
typedef Eigen\+::\+Triplet$<$ size\+\_\+t $>$ \hyperlink{transfer_operator_8hpp_a1921d2eced8b60b1c5a0e723ecf26269}{triplet\+U\+Int}
\begin{DoxyCompactList}\small\item\em Eigen triplet of integer. \end{DoxyCompactList}\item 
typedef std\+::vector$<$ \hyperlink{transfer_operator_8hpp_a1921d2eced8b60b1c5a0e723ecf26269}{triplet\+U\+Int} $>$ \hyperlink{transfer_operator_8hpp_adc891013819d036cc469cf9390668e35}{triplet\+U\+Int\+Vector}
\begin{DoxyCompactList}\small\item\em S\+TD vector of Eigen triplet of integer. \end{DoxyCompactList}\item 
typedef Eigen\+::\+Sparse\+Matrix$<$ double, Eigen\+::\+Col\+Major $>$ \hyperlink{transfer_operator_8hpp_ace75979355a5e6ee01cad82e4cdbc8f3}{Sp\+Mat\+C\+SC}
\begin{DoxyCompactList}\small\item\em Eigen C\+SC matrix of double type. \end{DoxyCompactList}\item 
typedef Eigen\+::\+Sparse\+Matrix$<$ double, Eigen\+::\+Row\+Major $>$ \hyperlink{transfer_operator_8hpp_a2ed0d254391fead9871fed96447cd51a}{Sp\+Mat\+C\+SR}
\begin{DoxyCompactList}\small\item\em Eigen C\+SR matrix of double type. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{transfer_operator_8hpp_af72f09779f83c1df7684ff0213106f03}{get\+Transition\+Matrix} (const gsl\+\_\+matrix\+\_\+uint $\ast$, const size\+\_\+t, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)
\item 
void \hyperlink{transfer_operator_8hpp_aa01223fcd18ff26b6fd4edd1b256c9ed}{get\+Transition\+Matrix} (const gsl\+\_\+matrix $\ast$, const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)
\item 
void \hyperlink{transfer_operator_8hpp_a395944b22c85b98ec0d33a441551e9b2}{get\+Transition\+Matrix} (const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, const size\+\_\+t tau\+Step, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, \hyperlink{atgraph_8hpp_aa17b7dc944934633434af049cdf173bd}{Sp\+Mat\+C\+SR} $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)
\item 
gsl\+\_\+matrix\+\_\+uint $\ast$ \hyperlink{transfer_operator_8hpp_a3f2f77112c5289a4dd7f03f8f3d60339}{get\+Grid\+Membership} (const gsl\+\_\+matrix $\ast$, const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)
\item 
gsl\+\_\+matrix\+\_\+uint $\ast$ \hyperlink{transfer_operator_8hpp_a21a051e585f52e4f7e0beaab7e3b2446}{get\+Grid\+Membership} (const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, const size\+\_\+t)
\item 
gsl\+\_\+vector\+\_\+uint $\ast$ \hyperlink{transfer_operator_8hpp_af29b6e8ba7d3e3f25a9a591369476419}{get\+Grid\+Membership} (const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)
\item 
gsl\+\_\+matrix\+\_\+uint $\ast$ \hyperlink{transfer_operator_8hpp_ab94854c9e153029424e930e032530dd9}{get\+Grid\+Membership} (gsl\+\_\+vector\+\_\+uint $\ast$, const size\+\_\+t)
\item 
int \hyperlink{transfer_operator_8hpp_a62519d9bb9a5d6cfe1862c3ba8b09692}{get\+Box\+Membership} (gsl\+\_\+vector $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)
\item 
std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$ \hyperlink{transfer_operator_8hpp_aab0310947de93163e25b252d385aa250}{get\+Grid\+Rect} (size\+\_\+t, size\+\_\+t, double, double)
\item 
std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$ \hyperlink{transfer_operator_8hpp_a39db75554db3e11c20aabcb03b106ea8}{get\+Grid\+Rect} (gsl\+\_\+vector\+\_\+uint $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)
\item 
void \hyperlink{transfer_operator_8hpp_ae9fcfe3bc8a2362a6652401863f9e46f}{write\+Grid\+Rect} (F\+I\+LE $\ast$, std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, bool)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Calculate discretized approximation of transfer operators from time series. 

Calculate discretized approximation of transfer operators from time series. The result is given as forward and backward Markov transition matrices and their distributions. 

\subsection{Typedef Documentation}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!Sp\+Mat\+C\+SC@{Sp\+Mat\+C\+SC}}
\index{Sp\+Mat\+C\+SC@{Sp\+Mat\+C\+SC}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{Sp\+Mat\+C\+SC}{SpMatCSC}}]{\setlength{\rightskip}{0pt plus 5cm}typedef Eigen\+::\+Sparse\+Matrix$<$double, Eigen\+::\+Col\+Major$>$ {\bf Sp\+Mat\+C\+SC}}\hypertarget{transfer_operator_8hpp_ace75979355a5e6ee01cad82e4cdbc8f3}{}\label{transfer_operator_8hpp_ace75979355a5e6ee01cad82e4cdbc8f3}


Eigen C\+SC matrix of double type. 

\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!Sp\+Mat\+C\+SR@{Sp\+Mat\+C\+SR}}
\index{Sp\+Mat\+C\+SR@{Sp\+Mat\+C\+SR}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{Sp\+Mat\+C\+SR}{SpMatCSR}}]{\setlength{\rightskip}{0pt plus 5cm}typedef Eigen\+::\+Sparse\+Matrix$<$double, Eigen\+::\+Row\+Major$>$ {\bf Sp\+Mat\+C\+SR}}\hypertarget{transfer_operator_8hpp_a2ed0d254391fead9871fed96447cd51a}{}\label{transfer_operator_8hpp_a2ed0d254391fead9871fed96447cd51a}


Eigen C\+SR matrix of double type. 

\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!triplet@{triplet}}
\index{triplet@{triplet}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{triplet}{triplet}}]{\setlength{\rightskip}{0pt plus 5cm}typedef Eigen\+::\+Triplet$<$double$>$ {\bf triplet}}\hypertarget{transfer_operator_8hpp_abf4a98d0009ef51cab3a1934054c6ddd}{}\label{transfer_operator_8hpp_abf4a98d0009ef51cab3a1934054c6ddd}


Eigen triplet of double. 

\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!triplet\+U\+Int@{triplet\+U\+Int}}
\index{triplet\+U\+Int@{triplet\+U\+Int}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{triplet\+U\+Int}{tripletUInt}}]{\setlength{\rightskip}{0pt plus 5cm}typedef Eigen\+::\+Triplet$<$size\+\_\+t$>$ {\bf triplet\+U\+Int}}\hypertarget{transfer_operator_8hpp_a1921d2eced8b60b1c5a0e723ecf26269}{}\label{transfer_operator_8hpp_a1921d2eced8b60b1c5a0e723ecf26269}


Eigen triplet of integer. 

\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!triplet\+U\+Int\+Vector@{triplet\+U\+Int\+Vector}}
\index{triplet\+U\+Int\+Vector@{triplet\+U\+Int\+Vector}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{triplet\+U\+Int\+Vector}{tripletUIntVector}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf triplet\+U\+Int}$>$ {\bf triplet\+U\+Int\+Vector}}\hypertarget{transfer_operator_8hpp_adc891013819d036cc469cf9390668e35}{}\label{transfer_operator_8hpp_adc891013819d036cc469cf9390668e35}


S\+TD vector of Eigen triplet of integer. 

\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!triplet\+Vector@{triplet\+Vector}}
\index{triplet\+Vector@{triplet\+Vector}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{triplet\+Vector}{tripletVector}}]{\setlength{\rightskip}{0pt plus 5cm}typedef std\+::vector$<${\bf triplet}$>$ {\bf triplet\+Vector}}\hypertarget{transfer_operator_8hpp_a9acc52217b04e27072f5918fd1bb00c7}{}\label{transfer_operator_8hpp_a9acc52217b04e27072f5918fd1bb00c7}


S\+TD vector of Eigen triplet of double. 



\subsection{Function Documentation}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Box\+Membership@{get\+Box\+Membership}}
\index{get\+Box\+Membership@{get\+Box\+Membership}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Box\+Membership(gsl\+\_\+vector $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)}{getBoxMembership(gsl_vector *, const std::vector< gsl_vector * > *)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Box\+Membership (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+vector $\ast$}]{state, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_a62519d9bb9a5d6cfe1862c3ba8b09692}{}\label{transfer_operator_8hpp_a62519d9bb9a5d6cfe1862c3ba8b09692}
Get membership to a grid box of a single realization 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em state} & G\+SL vector of a single state. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Box index to which the state belongs. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Membership@{get\+Grid\+Membership}}
\index{get\+Grid\+Membership@{get\+Grid\+Membership}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Membership(const gsl\+\_\+matrix $\ast$, const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)}{getGridMembership(const gsl_matrix *, const gsl_matrix *, const std::vector< gsl_vector * > *)}}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix\+\_\+uint $\ast$ get\+Grid\+Membership (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix $\ast$}]{init\+States, }
\item[{const gsl\+\_\+matrix $\ast$}]{final\+States, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_a3f2f77112c5289a4dd7f03f8f3d60339}{}\label{transfer_operator_8hpp_a3f2f77112c5289a4dd7f03f8f3d60339}
Get membership matrix from initial and final states for a grid. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em init\+States} & G\+SL matrix of initial states. \\
\hline
\mbox{\tt in}  & {\em final\+States} & G\+SL matrix of final states. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+SL grid membership matrix. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Membership@{get\+Grid\+Membership}}
\index{get\+Grid\+Membership@{get\+Grid\+Membership}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Membership(const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, const size\+\_\+t)}{getGridMembership(const gsl_matrix *, const std::vector< gsl_vector * > *, const size_t)}}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix\+\_\+uint $\ast$ get\+Grid\+Membership (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix $\ast$}]{states, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds, }
\item[{const size\+\_\+t}]{tau\+Step}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_a21a051e585f52e4f7e0beaab7e3b2446}{}\label{transfer_operator_8hpp_a21a051e585f52e4f7e0beaab7e3b2446}
Get the grid membership matrix from a single long trajectory. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em states} & G\+SL matrix of states for each time step. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\mbox{\tt in}  & {\em tau\+Step} & Lag used to calculate the transitions. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+SL grid membership matrix. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Membership@{get\+Grid\+Membership}}
\index{get\+Grid\+Membership@{get\+Grid\+Membership}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Membership(const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$)}{getGridMembership(const gsl_matrix *, const std::vector< gsl_vector * > *)}}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+vector\+\_\+uint $\ast$ get\+Grid\+Membership (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix $\ast$}]{states, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_af29b6e8ba7d3e3f25a9a591369476419}{}\label{transfer_operator_8hpp_af29b6e8ba7d3e3f25a9a591369476419}
Get the grid membership vector frm a single long trajectory. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em states} & G\+SL matrix of states for each time step. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+SL grid membership vector. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Membership@{get\+Grid\+Membership}}
\index{get\+Grid\+Membership@{get\+Grid\+Membership}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Membership(gsl\+\_\+vector\+\_\+uint $\ast$, const size\+\_\+t)}{getGridMembership(gsl_vector_uint *, const size_t)}}]{\setlength{\rightskip}{0pt plus 5cm}gsl\+\_\+matrix\+\_\+uint $\ast$ get\+Grid\+Membership (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+vector\+\_\+uint $\ast$}]{grid\+Mem\+Vect, }
\item[{const size\+\_\+t}]{tau\+Step}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_ab94854c9e153029424e930e032530dd9}{}\label{transfer_operator_8hpp_ab94854c9e153029424e930e032530dd9}
Get the grid membership matrix from the membership vector for a given lag. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em grid\+Mem\+Vect} & Grid membership vector of a long trajectory for a grid. \\
\hline
\mbox{\tt in}  & {\em tau\+Step} & Lag used to calculate the transitions. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
G\+SL grid membership matrix. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Rect@{get\+Grid\+Rect}}
\index{get\+Grid\+Rect@{get\+Grid\+Rect}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Rect(size\+\_\+t, size\+\_\+t, double, double)}{getGridRect(size_t, size_t, double, double)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$ get\+Grid\+Rect (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{dim, }
\item[{size\+\_\+t}]{nx, }
\item[{double}]{xmin, }
\item[{double}]{xmax}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_aab0310947de93163e25b252d385aa250}{}\label{transfer_operator_8hpp_aab0310947de93163e25b252d385aa250}
Get a uniform rectangular rectangular grid. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dim} & Number of dimensions. \\
\hline
\mbox{\tt in}  & {\em nx} & Number of boxes, identically for each dimension. \\
\hline
\mbox{\tt in}  & {\em xmin} & Minimum box limit, identically for each dimension. \\
\hline
\mbox{\tt in}  & {\em xmax} & Maximum box limit, identically for each dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\+TD vector of gsl\+\_\+vectors of grid box bounds for each dimension. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Grid\+Rect@{get\+Grid\+Rect}}
\index{get\+Grid\+Rect@{get\+Grid\+Rect}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Grid\+Rect(gsl\+\_\+vector\+\_\+uint $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)}{getGridRect(gsl_vector_uint *, gsl_vector *, gsl_vector *)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$ get\+Grid\+Rect (
\begin{DoxyParamCaption}
\item[{gsl\+\_\+vector\+\_\+uint $\ast$}]{nx, }
\item[{gsl\+\_\+vector $\ast$}]{xmin, }
\item[{gsl\+\_\+vector $\ast$}]{xmax}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_a39db75554db3e11c20aabcb03b106ea8}{}\label{transfer_operator_8hpp_a39db75554db3e11c20aabcb03b106ea8}
Get a uniform rectangular rectangular grid. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dim} & Number of dimensions. \\
\hline
\mbox{\tt in}  & {\em nx} & G\+SL vector giving the number of boxes for each dimension. \\
\hline
\mbox{\tt in}  & {\em xmin} & G\+SL vector giving the minimum box limit for each dimension. \\
\hline
\mbox{\tt in}  & {\em xmax} & G\+SL vector giving the maximum box limit for each dimension. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
S\+TD vector of gsl\+\_\+vectors of grid box bounds for each dimension. 
\end{DoxyReturn}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Transition\+Matrix@{get\+Transition\+Matrix}}
\index{get\+Transition\+Matrix@{get\+Transition\+Matrix}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Transition\+Matrix(const gsl\+\_\+matrix\+\_\+uint $\ast$, const size\+\_\+t, Sp\+Mat\+C\+S\+R $\ast$, Sp\+Mat\+C\+S\+R $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)}{getTransitionMatrix(const gsl_matrix_uint *, const size_t, SpMatCSR *, SpMatCSR *, gsl_vector *, gsl_vector *)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+Transition\+Matrix (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix\+\_\+uint $\ast$}]{grid\+Mem, }
\item[{const size\+\_\+t}]{N, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{P, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{Q, }
\item[{gsl\+\_\+vector $\ast$}]{init\+Dist, }
\item[{gsl\+\_\+vector $\ast$}]{final\+Dist}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_af72f09779f83c1df7684ff0213106f03}{}\label{transfer_operator_8hpp_af72f09779f83c1df7684ff0213106f03}
Get the forward and backward transition matrices and distributions from the membership matrix. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em grid\+Mem} & G\+SL grid membership matrix. \\
\hline
\mbox{\tt in}  & {\em N} & Number of grid boxes. \\
\hline
\mbox{\tt out}  & {\em P} & Eigen C\+SR forward transition matrix. \\
\hline
\mbox{\tt out}  & {\em Q} & Eigen C\+SR backward transition matrix. \\
\hline
\mbox{\tt out}  & {\em init\+Dist} & G\+SL vector of initial distribution. \\
\hline
\mbox{\tt out}  & {\em final\+Dist} & G\+SL vector of final distribution. \\
\hline
\end{DoxyParams}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Transition\+Matrix@{get\+Transition\+Matrix}}
\index{get\+Transition\+Matrix@{get\+Transition\+Matrix}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Transition\+Matrix(const gsl\+\_\+matrix $\ast$, const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, Sp\+Mat\+C\+S\+R $\ast$, Sp\+Mat\+C\+S\+R $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)}{getTransitionMatrix(const gsl_matrix *, const gsl_matrix *, const std::vector< gsl_vector * > *, SpMatCSR *, SpMatCSR *, gsl_vector *, gsl_vector *)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+Transition\+Matrix (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix $\ast$}]{init\+States, }
\item[{const gsl\+\_\+matrix $\ast$}]{final\+States, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{P, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{Q, }
\item[{gsl\+\_\+vector $\ast$}]{init\+Dist, }
\item[{gsl\+\_\+vector $\ast$}]{final\+Dist}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_aa01223fcd18ff26b6fd4edd1b256c9ed}{}\label{transfer_operator_8hpp_aa01223fcd18ff26b6fd4edd1b256c9ed}
Get the forward and backward transition matrices and distributions from the initial and final states of trajectories. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em init\+States} & G\+SL matrix of initial states. \\
\hline
\mbox{\tt in}  & {\em final\+States} & G\+SL matrix of final states. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\mbox{\tt out}  & {\em P} & Eigen C\+SR forward transition matrix. \\
\hline
\mbox{\tt out}  & {\em Q} & Eigen C\+SR backward transition matrix. \\
\hline
\mbox{\tt out}  & {\em init\+Dist} & G\+SL vector of initial distribution. \\
\hline
\mbox{\tt out}  & {\em final\+Dist} & G\+SL vector of final distribution. \\
\hline
\end{DoxyParams}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!get\+Transition\+Matrix@{get\+Transition\+Matrix}}
\index{get\+Transition\+Matrix@{get\+Transition\+Matrix}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{get\+Transition\+Matrix(const gsl\+\_\+matrix $\ast$, const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, const size\+\_\+t tau\+Step, Sp\+Mat\+C\+S\+R $\ast$, Sp\+Mat\+C\+S\+R $\ast$, gsl\+\_\+vector $\ast$, gsl\+\_\+vector $\ast$)}{getTransitionMatrix(const gsl_matrix *, const std::vector< gsl_vector * > *, const size_t tauStep, SpMatCSR *, SpMatCSR *, gsl_vector *, gsl_vector *)}}]{\setlength{\rightskip}{0pt plus 5cm}void get\+Transition\+Matrix (
\begin{DoxyParamCaption}
\item[{const gsl\+\_\+matrix $\ast$}]{states, }
\item[{const std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds, }
\item[{const size\+\_\+t}]{tau\+Step, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{P, }
\item[{{\bf Sp\+Mat\+C\+SR} $\ast$}]{Q, }
\item[{gsl\+\_\+vector $\ast$}]{init\+Dist, }
\item[{gsl\+\_\+vector $\ast$}]{final\+Dist}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_a395944b22c85b98ec0d33a441551e9b2}{}\label{transfer_operator_8hpp_a395944b22c85b98ec0d33a441551e9b2}
Get the forward and backward transition matrices and distributions from a single long trajectory. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em states} & G\+SL matrix of states for each time step. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\mbox{\tt in}  & {\em tau\+Step} & Lag used to calculate the transitions. \\
\hline
\mbox{\tt out}  & {\em P} & Eigen C\+SR forward transition matrix. \\
\hline
\mbox{\tt out}  & {\em Q} & Eigen C\+SR backward transition matrix. \\
\hline
\mbox{\tt out}  & {\em init\+Dist} & G\+SL vector of initial distribution. \\
\hline
\mbox{\tt out}  & {\em final\+Dist} & G\+SL vector of final distribution. \\
\hline
\end{DoxyParams}
\index{transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}!write\+Grid\+Rect@{write\+Grid\+Rect}}
\index{write\+Grid\+Rect@{write\+Grid\+Rect}!transfer\+Operator.\+hpp@{transfer\+Operator.\+hpp}}
\subsubsection[{\texorpdfstring{write\+Grid\+Rect(\+F\+I\+L\+E $\ast$, std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$, bool)}{writeGridRect(FILE *, std::vector< gsl_vector * > *, bool)}}]{\setlength{\rightskip}{0pt plus 5cm}void write\+Grid\+Rect (
\begin{DoxyParamCaption}
\item[{F\+I\+LE $\ast$}]{fp, }
\item[{std\+::vector$<$ gsl\+\_\+vector $\ast$ $>$ $\ast$}]{grid\+Bounds, }
\item[{bool}]{verbose = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{transfer_operator_8hpp_ae9fcfe3bc8a2362a6652401863f9e46f}{}\label{transfer_operator_8hpp_ae9fcfe3bc8a2362a6652401863f9e46f}
Print a uniform rectangular grid to filel 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em fp} & File descriptor of the file to which to print the grid. \\
\hline
\mbox{\tt in}  & {\em grid\+Bounds} & S\+TD vector of gsl\+\_\+vector of grid box bounds for each dimension. \\
\hline
\mbox{\tt in}  & {\em verbose} & If true, also print to the standard output. \\
\hline
\end{DoxyParams}
